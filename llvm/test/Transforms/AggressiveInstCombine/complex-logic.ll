; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=aggressive-instcombine -enable-clc-for-all -S | FileCheck %s

define i1 @leaf1_and_aa(i1 %a)  {
; CHECK-LABEL: @leaf1_and_aa(
; CHECK-NEXT:    ret i1 [[A:%.*]]
;
  %and.aa = and i1 %a, %a
  ret i1 %and.aa
}

define i1 @leaf1_and_a_false(i1 %a)  {
; CHECK-LABEL: @leaf1_and_a_false(
; CHECK-NEXT:    ret i1 false
;
  %and.aa = and i1 %a, false
  ret i1 %and.aa
}

define i1 @leaf1_xor_aa(i1 %a)  {
; CHECK-LABEL: @leaf1_xor_aa(
; CHECK-NEXT:    ret i1 false
;
  %xor.aa = xor i1 %a, %a
  ret i1 %xor.aa
}

define i1 @leaf1_and_not(i1 %a)  {
; CHECK-LABEL: @leaf1_and_not(
; CHECK-NEXT:    ret i1 false
;
  %not.a = xor i1 %a, true
  %and = and i1 %a, %not.a
  ret i1 %and
}

define i1 @leaf1_or_not(i1 %a)  {
; CHECK-LABEL: @leaf1_or_not(
; CHECK-NEXT:    ret i1 true
;
  %not.a = xor i1 %a, true
  %or = or i1 %a, %not.a
  ret i1 %or
}

define i1 @leaf2_xor(i1 %a, i1 %b)  {
; CHECK-LABEL: @leaf2_xor(
; CHECK-NEXT:    ret i1 [[B:%.*]]
;
  %ab = xor i1 %a, %b
  %xor.ab.a = xor i1 %ab, %a
  ret i1 %xor.ab.a
}

define i1 @leaf2_xor_ret_const_false(i1 %a, i1 %b)  {
; CHECK-LABEL: @leaf2_xor_ret_const_false(
; CHECK-NEXT:    ret i1 false
;
  %xor.ab = xor i1 %a, %b
  %xor.ab.a = xor i1 %xor.ab, %a
  %xor.ab.a.b = xor i1 %xor.ab.a, %b
  ret i1 %xor.ab.a.b
}

define i1 @leaf2_or_ret_leaf(i1 %a, i1 %b)  {
; CHECK-LABEL: @leaf2_or_ret_leaf(
; CHECK-NEXT:    ret i1 [[B:%.*]]
;
  %or.ab = or i1 %a, %b
  %and.ab = and i1 %a, %b
  %xor1 = xor i1 %or.ab, %and.ab
  %xor2 = xor i1 %xor1, %a
  ret i1 %xor2
}

define i1 @leaf2_or_ret_const_false(i1 %a, i1 %b)  {
; CHECK-LABEL: @leaf2_or_ret_const_false(
; CHECK-NEXT:    ret i1 [[A:%.*]]
;
  %or.ab = or i1 %a, %b
  %and.ab = and i1 %a, %b
  %xor1 = xor i1 %or.ab, %and.ab
  %xor2 = xor i1 %xor1, %a
  %xor3 = xor i1 %xor1, %b
  ret i1 %xor3
}

define i4 @leaf2_type_is_i4(i4 %a, i4 %b) {
; CHECK-LABEL: @leaf2_type_is_i4(
; CHECK-NEXT:    ret i4 -1
;
  %xor.ab = xor i4 %a, %b
  %not.a = xor i4 %a, -1
  %xor2 = xor i4 %not.a, %b
  %or = or i4 %xor2, %xor.ab
  ret i4 %or
}

define i1 @leaf3_complex_ret_const_false(i1 %a, i1 %b, i1 %c)  {
; CHECK-LABEL: @leaf3_complex_ret_const_false(
; CHECK-NEXT:    ret i1 false
;
  %ab = or i1 %a, %b
  %abc = or i1 %ab, %c
  %not.abc = xor i1 %abc, true
  %r = and i1 %not.abc, %a
  ret i1 %r
}

define i1 @leaf3_complex_ret_leaf(i1 %a, i1 %b, i1 %c) {
; CHECK-LABEL: @leaf3_complex_ret_leaf(
; CHECK-NEXT:    ret i1 [[C:%.*]]
;
  %ab = and i1 %a, %b
  %bc = and i1 %b, %c
  %xor.ac = xor i1 %a, %c
  %or = or i1 %ab, %xor.ac
  %not.bc = xor i1 %bc, true
  %and = and i1 %not.bc, %a
  %cond = xor i1 %and, %or
  ret i1 %cond
}

define i1 @leaf4_ret_const_true(i1 %a, i1 %b, i1 %c, i1 %d)  {
; CHECK-LABEL: @leaf4_ret_const_true(
; CHECK-NEXT:    ret i1 true
;
  %bd = and i1 %b, %d
  %not.bd = xor i1 %bd, true
  %xor.ab = xor i1 %a, %b
  %or1 = or i1 %xor.ab, %c
  %or2 = or i1 %or1, %not.bd
  %or3 = or i1 %or2, %a
  ret i1 %or3
}

define i1 @leaf4_ret_leaf(i1 %a, i1 %b, i1 %c, i1 %d)  {
; CHECK-LABEL: @leaf4_ret_leaf(
; CHECK-NEXT:    ret i1 [[B:%.*]]
;
  %bd = and i1 %b, %d
  %xor = xor i1 %bd, %c
  %not.bd = xor i1 %xor, true
  %xor.ab = xor i1 %a, %b
  %or1 = or i1 %xor.ab, %c
  %or2 = or i1 %or1, %not.bd
  %or3 = or i1 %or2, %a
  %and = and i1 %or3, %b
  ret i1 %and
}

define i1 @leaf4_ret_leaf2(i1 %a, i1 %b, i1 %c, i1 %d)  {
; CHECK-LABEL: @leaf4_ret_leaf2(
; CHECK-NEXT:    ret i1 [[B:%.*]]
;
  %bd = and i1 %b, %d
  %xor = xor i1 %bd, %c
  %not.bd = xor i1 %xor, true
  %xor.ab = xor i1 %a, %b
  %or1 = or i1 %xor.ab, %c
  %or2 = or i1 %or1, %not.bd
  %or3 = or i1 %or2, %a
  %and = and i1 %or3, %b
  ret i1 %and
}
